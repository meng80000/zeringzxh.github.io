---
title: 汇编指令
date: 2018-09-05 14:42:45
tags: 汇编指令
categories: 汇编
---
## 数据定义
db定义字节类型变量，一个字节数据占1个字节（8位）单元，读完一个，偏移量加1
dw定义字类型变量，一个字数据占2个字节（16位）单元，读完一个，偏移量加2
dd定义双字类型变量，一个双字数据占4个字节（32位）单元，读完一个，偏移量加4
dup操作符用来进行数据的重复：
db 重复的次数 dup (重复的字节型数据)。
dw 重复的次数 dup (重复的字型数据)。
dd 重复的次数 dup (重复的双字数据)。
<!--more-->
## 寄存器相关
### 通用寄存器
8086CPU的AX、BX、CX、DX四个16位寄存器都可分为两个独立使用的8位寄存器来用：
* AX可分为AH和AL
* BX可分为BH和BL
* CX可分为CH和CL
* DX可分为DH和DL

| 汇编指令  | 功能                | 高级语言描述 |
| --------- | ------------------- | ------------ |
| mov ax,18 | 将18送入寄存器ax    | ax=18        |
| add ax,8  | 将寄存器ax中的值加8 | ax=ax+8      |
| sub ax,8  | 将寄存器ax中的值减8 | ax=ax-8      |
| inc ax    | 将寄存器ax中的值加1 | ax=ax+1      |

### 段寄存器&指令指针寄存器
8086CPU有4个段寄存器：CS、DS、SS、ES。访问内存时由4个段寄存器提供内存单元的段地址。
IP为指令指针寄存器，任意时刻，CPU将CS:IP指向的内容当作指令执行。
CS值*16+IP值

jmp指令同时修改CS、IP的内容：
jmp 2AE3:3,执行后：CS=2AE3H，IP=0003H，CPU从2AE33H处读取指令
jmp指令仅仅修改IP的内容：
jmp ax,执行前：ax=1000H，CS=2AE3H，IP=0003H
       执行后：ax=1000H，CS=2AE3H，IP=1000H

### DS&[address]
DS存放要访问数据的段地址，[address]中address表示偏移地址。
| 汇编指令     | 执行后相关寄存器中内容 | 说明                                |
| ------------ | ---------------------- | ----------------------------------- |
| mov ax,1000H | ax=1000H               |                                     |
| mov ds,ax    | ds=1000H               | 寄存器ds设为1000H                   |
| mov ax,[0]   |                        | 将1000H:0中存放的字型数据存放到ax中 |

### 栈
SS段寄存器存放栈顶地址，SP寄存器存放偏移地址。任意时刻，SS:SP都指向栈顶元素。
push ax时，SP-2，SS:SP指向栈顶。pop ax时，SP+2，SS:SP指向栈顶。

## and和or指令
and指令：逻辑与指令，按位进行与运算。
or指令：逻辑或指令，按位进行或运算。

## div指令
除法指令：
1. 除数：有8位和16位两种，在一个寄存器或内存单元中
2. 被除数：默认放在AX或DX和AX中，若除数为8位，则被除数16位，存放AX中；若除数为16位，被除数为32位，存放DX和AX中，DX存放高位，AX存放低位。
3. 结果：若除数为8位，则AL存放除法操作的商，AH存放除法操作的余数。若为16位，则AX存放商，DX存放余数。

例子：
div byte ptr ds:[0]
含义：(al)=(ax)/((ds)*16+0)的商
      (ah)=(ax)/((ds)*16+0)的余数

div word ptr es:[0]
含义：(ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商
     (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数

## mul指令
乘法指令：
1. 两个相乘的数，要么都是8位，要么都是16位。若为8位，一个默认放在AH中，另一个放在8位寄存器或内存字节单元中；若为16位，一个默认放在AX中，另一个放在16位寄存器或内存字节单元中。
2. 结果：若是8位乘法，结果默认放在AX中；若是16位，结果高位默认放在DX中，低位在AX中。

## 转移指令
### 操作符offset
offset：取得标号的偏移地址
mov ax,offset start相当与mov ax,0;start为代码段中的标号，所标记的指令为代码中的第一条指令，偏移地址为0。

### jmp指令
jmp为无条件转移指令。可以只修改IP，也可同时修改CS和IP。
jmp short 标号（转到标号处执行指令）
"jmp short 标号"功能：(IP)=(IP)+8位位移。
"jmp near ptr 标号"功能：(IP)=(IP)+16。
"jmp far ptr 标号"实现段间转移，又称远转移。功能：(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。

### Jxx
功能: 当特定条件成立则跳往指定地址执行
语法: JXX 地址
注:
A: ABOVE,当C=0,Z=0时成立
B: BELOW,当C=1时成立
C: CARRY,当弁时成立 CXZ: CX寄存器的值为0(ZERO)时成立
E: EQUAL,当Z=1时成立
G: GREATER(大于),当Z=0且S=0时成立
L: LESS(小于),当S不为零时成立
N: NOT(相反条件),需和其它符号配合使用
O: OVERFLOW,O=1时成立
P: PARITY,P=1时成立
PE: PARITY EVEN,P=1时成立
PO: PARITY ODD,P=0时成立
S: SIGN,S=1时成立
Z: ZERO,Z=1时成立
jcxz：有条件转移指令且为短转移，指令格式：jcxz 标号（如果(cx)=0，转移到标号处执行）。当(cx)!=0时，什么都不做（程序向下执行）。
"jcxz 标号"功能相当于if((cx)==0)jmp short 标号；

### loop指令
loop为循环控制指令，loop指令格式：loop 标号；CPU执行loop指令时，进行两步操作：
1. cx值=cx值-1；
2. 判断cx中的值，不为0则跳转至标号处执行程序，如果为0则向下执行。

### ret和retf
ret指令用栈中数据修改IP的内容，从而实现近转移，相当与pop IP。
retf指令用栈中数据修改CS和IP的内容，从而实现远转移，相当于pop IP后在pop CS。

### call指令
call指令进行两步操作：
1. 将当前的IP或CS和IP压入栈中；
2. 转移。
call指令不能实现短转移。执行call相当于执行：
```
push IP
jmp near ptr 标号
```
转移的目的地址在指令中的call指令，"call far ptr 标号"实现段间转移，相当于：
```
push CS
push IP
jmp far ptr 标号
```

## 推荐阅读
[常用的汇编指令](https://blog.csdn.net/qq_33733970/article/details/78572733)

## 指令大全
![](2018-09-05-汇编指令\汇编指令大全.png)
