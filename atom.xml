<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zering的博客</title>
  
  <subtitle>记录点滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zeringzxh.github.io/"/>
  <updated>2018-07-12T07:50:11.016Z</updated>
  <id>http://zeringzxh.github.io/</id>
  
  <author>
    <name>zering</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>流量分析入门</title>
    <link href="http://zeringzxh.github.io/2018/07/12/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90%E5%85%A5%E9%97%A8/"/>
    <id>http://zeringzxh.github.io/2018/07/12/流量分析入门/</id>
    <published>2018-07-12T06:34:19.000Z</published>
    <updated>2018-07-12T07:50:11.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NetFlow"><a href="#NetFlow" class="headerlink" title="NetFlow"></a>NetFlow</h2><p>NetFlow是一种数据交换方式，由思科于1990年开发。其工作原理是：NetFlow利用标准的交换模式处理数据流的第一个IP包数据，生成NetFlow缓存，随后同样的数据基于缓存信息在同一个数据流中进行传输，不再匹配相关的访问控制等策略，NetFlow缓存同时包含了随后数据流的统计信息。<br><a id="more"></a></p><h3 id="NetFlow输出格式"><a href="#NetFlow输出格式" class="headerlink" title="NetFlow输出格式"></a>NetFlow输出格式</h3><p>NetFlow输出格式为报头+一系列Flow流。报头包含序列号、记录数、系统时间等，Flow流包含IP地址、端口、路由信息等。</p><p>一个IP数据包的Flow流至少定义了7个关键元素：</p><ul><li>源IP地址；</li><li>目的IP地址；</li><li>源端口号；</li><li>目的端口号；</li><li>第三层协议类型；</li><li>TOS字段；</li><li>网络设备输入/输出的逻辑端口。</li></ul><p>OSSIM提供可视化NetFlow图形界面，如下图：<br><img src="/2018/07/12/流量分析入门/NetFlow.png" alt=""></p><h3 id="NetFlow监测恶意代码"><a href="#NetFlow监测恶意代码" class="headerlink" title="NetFlow监测恶意代码"></a>NetFlow监测恶意代码</h3><p>NetFlow数据流获取方便，当网络正常运行时，NetFlow数据流是有一定的规律性的，当网络中存在异常流量时，网络流量会发生异常的波动。<br>监测蠕虫的策略：选取几个不同时间段，若时间段内符合特征的Flow超过上限值，则为病毒。</p><h3 id="反应网络运行的核心参数"><a href="#反应网络运行的核心参数" class="headerlink" title="反应网络运行的核心参数"></a>反应网络运行的核心参数</h3><ul><li>平均每秒流量：如果网络内部存在大流量的攻击或P2P等大流量的下载等异常流量时，其数值会比正常时大很多。</li><li>平均每秒包数：大部分的异常流量都会产生非常多的数据包数。</li><li>数据包大小分布：64字节左右的小包和1500字节左右的大包的分布比例较小，小包过多，可能存在扫描、攻击行为，大包过多可能存在消耗带宽资源的大包DOS攻击行为。<br>*平均包长：网络内的平均包长会在500-700字节左右。</li><li>TCP会话数、UDP会话数、IP地址个数、MAC地址个数。。。</li></ul><h2 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h2><p> WireShark是目前世界上最流行的网络分析工具，如下图：<br><img src="/2018/07/12/流量分析入门/WireShark.png" alt=""></p><h3 id="界面详解"><a href="#界面详解" class="headerlink" title="界面详解"></a>界面详解</h3><p>1.过滤器规则：</p><ul><li>tcp-&gt;只显示TCP协议的记录；</li><li>http-&gt;只看HTTP协议的记录；</li><li>ip.src ==192.168.1.102 -&gt;显示源地址为192.168.1.102的记录；</li><li>ip.dst==192.168.1.102 -&gt;目标地址为192.168.1.10的记录；</li><li>ip.addr == 42.121.252.58 -&gt;只显示与某主机的通信；</li><li>tcp.port ==80-&gt;端口为80的；</li><li>tcp.srcport == 80 -&gt;只显示TCP协议的源端口为80的；</li><li>http.request.method==”GET”  -&gt;只显示HTTP GET方法的；</li><li>eth.type == 0x806-&gt;只显示ARP报文，这个字段的值表示是ARP报文，如果是ip报文此值为0x8000（可在表达式中选取对应的16进制值）。</li></ul><p>2.封包列表：<br>封包列表的面板中显示，编号，时间戳，源地址，目标地址，协议，长度，以及封包信息。</p><p>3.封包的详细信息：<br>在封包信息中，每行对应的含义及在OSI模型中的对应关系如下：</p><ul><li>Frame:   物理层的数据帧概况  -&gt;对应OSI七层模型中的【物理层】</li><li>Ethernet II: 数据链路层以太网帧头部信息  -&gt;对应OSI七层模型中的【数据链路层】</li><li>Internet Protocol Version 4: 互联网层IP包头部信息  -&gt;对应OSI七层模型中的【网络层】</li><li>Transmission Control Protocol:  传输层T的数据段头部信息，此处是TCP  -&gt;对应OSI七层模型中的【传输层】</li><li>Hypertext Transfer Protocol:  应用层的信息，此处是HTTP协议  -&gt;对应OSI七层模型中的【应用层】</li></ul><h3 id="WireShark统计模块"><a href="#WireShark统计模块" class="headerlink" title="WireShark统计模块"></a>WireShark统计模块</h3><h4 id="捕获文件的属性"><a href="#捕获文件的属性" class="headerlink" title="捕获文件的属性"></a>捕获文件的属性</h4><p><img src="/2018/07/12/流量分析入门/文件属性.PNG" alt=""><br>这一菜单简单收集所有抓包数据，在定义了过滤条件的时候，将呈现过滤后的数据。当想要知道每秒的平均报文数或是字节数时，可以使用此工具。</p><h4 id="Endpoint"><a href="#Endpoint" class="headerlink" title="Endpoint"></a>Endpoint</h4><p><img src="/2018/07/12/流量分析入门/统计_Endpoints.png" alt=""><br>此窗口中，能够看到第2,3,4层的endpoints，也就是以太网，IP, TCP或UDP。查看收发大量数据流的IP地址。</p><h4 id="Conversations"><a href="#Conversations" class="headerlink" title="Conversations"></a>Conversations</h4><p><img src="/2018/07/12/流量分析入门/Conversations.PNG" alt=""><br>显示2层以太网统计数据，第3层IP统计数据，或第4层TCP或UDP统计数据，网络会话是两个指定终端之间的数据流。例如，IP会话是两个IP地址之间的所有数据流，TCP会话包含了所有TCP连接。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/Chilam007/p/6973990.html" target="_blank" rel="noopener"> 抓包工具 - Wireshark（详细介绍与TCP三次握手数据分析）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NetFlow&quot;&gt;&lt;a href=&quot;#NetFlow&quot; class=&quot;headerlink&quot; title=&quot;NetFlow&quot;&gt;&lt;/a&gt;NetFlow&lt;/h2&gt;&lt;p&gt;NetFlow是一种数据交换方式，由思科于1990年开发。其工作原理是：NetFlow利用标准的交换模式处理数据流的第一个IP包数据，生成NetFlow缓存，随后同样的数据基于缓存信息在同一个数据流中进行传输，不再匹配相关的访问控制等策略，NetFlow缓存同时包含了随后数据流的统计信息。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="流量分析" scheme="http://zeringzxh.github.io/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
    
    
      <category term="NetFlow" scheme="http://zeringzxh.github.io/tags/NetFlow/"/>
    
      <category term="WireShark" scheme="http://zeringzxh.github.io/tags/WireShark/"/>
    
  </entry>
  
  <entry>
    <title>渗透测试-公司内网</title>
    <link href="http://zeringzxh.github.io/2018/06/28/%E5%9F%9F%E6%B8%97%E9%80%8F-%E5%85%AC%E5%8F%B8%E5%86%85%E7%BD%91/"/>
    <id>http://zeringzxh.github.io/2018/06/28/域渗透-公司内网/</id>
    <published>2018-06-28T00:43:04.000Z</published>
    <updated>2018-06-28T10:30:20.911Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-问题发现"><a href="#0x01-问题发现" class="headerlink" title="0x01 问题发现"></a>0x01 问题发现</h2><p>前段时间在公司内网搭建了OSSIM，对公司10.10.66.1/24网段进行扫描，发现10.10.66.239存在严重漏洞，如下图：<br><img src="/2018/06/28/域渗透-公司内网/漏洞.PNG" alt=""><br><a id="more"></a></p><h2 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h2><p>直接打开kali中神器msf，里面已经有ms17-010的poc，利用后获取meterpreter，如下图：<br><img src="/2018/06/28/域渗透-公司内网/meterpreter.PNG" alt=""></p><p>查看权限，直接为system权限。</p><p><img src="/2018/06/28/域渗透-公司内网/getuid.PNG" alt=""></p><p>其他查看信息的命令不一一列举。</p><p>进入cmd，发现kali控制台显示乱码，使用chcp 65001命令解决：</p><p><img src="/2018/06/28/域渗透-公司内网/乱码.PNG" alt=""></p><p>查看systeminfo信息，发现是域控。。。。。</p><p><img src="/2018/06/28/域渗透-公司内网/域控.PNG" alt=""></p><h2 id="0x02-域信息收集"><a href="#0x02-域信息收集" class="headerlink" title="0x02 域信息收集"></a>0x02 域信息收集</h2><p>windows server机器，使用dsget和dsquery进行域信息收集。<br>使用命令查看全域信息，内容太多，就不截图了<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery * -limit <span class="number">0</span> -attr *</span><br></pre></td></tr></table></figure></p><hr><p>CN, OU, DC 都是 LDAP 连接服务器的端字符串中的区别名称（DN, distinguished   name）</p><pre><code>DC (Domain Component)CN (Common Name)OU (Organizational Unit)</code></pre><p>例如：CN=test,OU=developer,DC=domainname,DC=com</p><p>在上面的代码中 cn=test 可能代表一个用户名，ou=developer 代表一个 active directory 中的组织单位。这句话的含义可能就是说明 test 这个对象处在domainname.com 域的 developer 组织单元中</p><hr><p>查看域控制器，这里已经是域控制器，就不查看了。域控制器命令<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dsquery server -limit <span class="number">0</span> | dsget server -dn -desc -dnsname -site -isgc</span><br></pre></td></tr></table></figure></p><p>其dsquery和dsget命令不一一列举。</p><p>使用net查看命令查看域信息。<br>net group /do</p><p><img src="/2018/06/28/域渗透-公司内网/net_group.PNG" alt=""></p><p>查看Domain Admins组成员，使用dsquery同样可以查询。<br>net group “Domain Admins” /do</p><p><img src="/2018/06/28/域渗透-公司内网/Domain_Admins.PNG" alt=""></p><p>在上面，我们使用net view查看信息时报错：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System error <span class="number">6118</span> has occurred.</span><br><span class="line"></span><br><span class="line">The list of servers <span class="keyword">for</span> this workgroup is <span class="keyword">not</span> currently available</span><br></pre></td></tr></table></figure></p><p>需要从services.msc中打开Computer Browser，先将域管理员用户打开。</p><h2 id="0x03-后记"><a href="#0x03-后记" class="headerlink" title="0x03 后记"></a>0x03 后记</h2><p>公司内网，就不使用mimikatz进行获取密码了。下班了，其他情况日后再说。<br>黄金票据，白银票据等内容可以查看此博客：<br><a href="https://1sparrow.com/2018/02/19/%E5%9F%9F%E6%B8%97%E9%80%8F%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">域渗透相关</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-问题发现&quot;&gt;&lt;a href=&quot;#0x01-问题发现&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题发现&quot;&gt;&lt;/a&gt;0x01 问题发现&lt;/h2&gt;&lt;p&gt;前段时间在公司内网搭建了OSSIM，对公司10.10.66.1/24网段进行扫描，发现10.10.66.239存在严重漏洞，如下图：&lt;br&gt;&lt;img src=&quot;/2018/06/28/域渗透-公司内网/漏洞.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="渗透测试" scheme="http://zeringzxh.github.io/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://zeringzxh.github.io/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
      <category term="内网" scheme="http://zeringzxh.github.io/tags/%E5%86%85%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Cuckoo-Sandbox学习-安装篇</title>
    <link href="http://zeringzxh.github.io/2018/06/06/Cuckoo-Sandbox%E5%AD%A6%E4%B9%A0-%E5%AE%89%E8%A3%85%E7%AF%87/"/>
    <id>http://zeringzxh.github.io/2018/06/06/Cuckoo-Sandbox学习-安装篇/</id>
    <published>2018-06-06T06:11:45.000Z</published>
    <updated>2018-06-09T10:57:33.375Z</updated>
    
    <content type="html"><![CDATA[<p>Cuckoo Sandbox是一个开源的恶意文件自动化分析系统，通过Cuckoo Sandbox可以方便地帮助安全研究人员验证恶意程序的特征信息。</p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>本人在vmware中建立两个虚拟机，一个host，一个guest。<br>VMware 12 Pro<br>ubuntu-16.04.1-desktop-amd64<br>window7-64bit<br><a id="more"></a></p><h2 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h2><p>使用vmware安装ubuntu-16.04.1-desktop-amd64，添加2个网卡，一个NAT模式，一个内网网卡。<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/网卡-ubuntu.PNG" alt=""></p><p>依赖库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install python python-pip python-dev libffi-dev libssl-dev</span><br><span class="line">$ sudo apt-get install python-virtualenv python-setuptools</span><br><span class="line">$ sudo apt-get install libjpeg-dev zlib1g-dev swig</span><br></pre></td></tr></table></figure></p><p>为了使用基于Django的Web界面,使用PostgreSQL作为数据库，需要安装MongoDB和PostgreSQL。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install mongodb</span><br><span class="line">$ sudo apt-get install postgresql libpq-dev</span><br></pre></td></tr></table></figure></p><p>建议首先升级pip和setuptools库，因为它们经常过时，导致试图安装Cuckoo时出现问题<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U pip setuptools</span><br></pre></td></tr></table></figure></p><hr><p>若使用virtual box则创建一个cuckoo用户，将其添加到vboxusers组里<font color="red">（VirtualBox安装后创建）</font>。确保运行Cuckoo的用户与用于创建和运行虚拟机的用户相同（至少在VirtualBox的情况下），否则Cuckoo将无法识别和启动这些虚拟机。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo adduser cuckoo</span><br><span class="line">$ sudo usermod -a -G vboxusers cuckoo</span><br></pre></td></tr></table></figure></p><p>安装VirtualBox<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install virtualbox</span><br></pre></td></tr></table></figure></p><hr><h2 id="安装Cuckoo"><a href="#安装Cuckoo" class="headerlink" title="安装Cuckoo"></a>安装Cuckoo</h2><p>使用一条命令安装<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install -U cuckoo</span><br></pre></td></tr></table></figure></p><p>部分依赖需要翻墙，安装成功如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/install.PNG" alt=""></p><p>如果在本地使用virtual box则切换cuckoo用户并运行，<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/run.PNG" alt=""></p><p>从中可以看出配置文件路径为<em>/home/cuckoo/.cuckoo/conf</em>，工作目录路径可以修改，.cuckoo为隐藏目录，使用<code>ctrl+h</code>查看隐藏文件。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>几个主要的配置文件：</p><ul><li>cuckoo.conf：用于配置常规行为和分析选项。</li><li>auxiliary.conf：用于启用和配置辅助模块。</li><li>\<machinery>.conf：用于定义虚拟化软件的选项（该文件与您在cuckoo.conf中选择的机器模块名称相同,virtualbox.conf和vmware.conf）。</machinery></li><li>memory.conf：波动配置。</li><li>processing.conf：用于启用和配置处理模块。</li><li>reporting.conf：用于启用或禁用报告格式。</li></ul><h2 id="客户机安装及配置"><a href="#客户机安装及配置" class="headerlink" title="客户机安装及配置"></a>客户机安装及配置</h2><p>使用vmware安装windows7 64bit，配置一个内网网卡。<br>查看ubuntu16.04.1的ip地址，配置window7客户机的ipv4地址的默认网关和DNS地址为ubuntu的ip地址，如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/ip-windows7.PNG" alt=""></p><p>安装python2.7.10，并关闭windows防火墙和自动更新，原因为他们可能影响恶意软件的行为。<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/win7配置.PNG" alt=""></p><p>为了正常运行，需要配置如下一些选项。</p><ul><li>启用自动登录</li><li>启用远程RPC</li><li>关闭分页（可选）</li><li>禁用屏幕保护程序（可选）</li></ul><p>在Windows 7中，以管理员权限打开管理命令提示符，输入以下命令以启用自动登录和远程RPC。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v DefaultUserName /d &lt;USERNAME&gt; /t REG_SZ /f</span><br><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v DefaultPassword /d &lt;PASSWORD&gt; /t REG_SZ /f</span><br><span class="line">reg add "hklm\software\Microsoft\Windows NT\CurrentVersion\WinLogon" /v AutoAdminLogon /d <span class="number">1</span> /t REG_SZ /f</span><br><span class="line">reg add "hklm\system\CurrentControlSet\Control\TerminalServer" /v AllowRemoteRPC /d <span class="number">0</span>x01 /t REG_DWORD /f</span><br><span class="line">reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v LocalAccountTokenFilterPolicy /d <span class="number">0</span>x01 /t REG_DWORD /f</span><br></pre></td></tr></table></figure></p><p>前两条命令里的 \<username> 和 \<password> 为自己的账户和密码。</password></username></p><p>找到之前安装的cuckoo路径下的agent/agent.py,并将其放到win7的启动目录下，<code>C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>，把agent.py后缀改为agent.pyw，这样程序启动就不会有GUI窗口。</p><h2 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h2><p>很多恶意软件都需要访问网络才可以正常运行，因此需要配置windows主机上网，使用host主机开启流量转发、用 iptables 做地址转换（NAT）规则。</p><p>临时开启ip转发功能方式，系统重启之后便失效：</p><ul><li>sudo sysctl -w net.ipv4.ip_forward=1</li><li>sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward</li></ul><p>若要重启后仍然有效，则需修改配置文件/etc/sysctl.conf，去掉net.ipv4.ip_forward=1 前的注释，之后执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sysctl -p /etc/sysctl.conf</span><br></pre></td></tr></table></figure></p><p>然后配置Iptables的规则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -A FORWARD -o eth0 -i vboxnet0 -s 192.168.56.0/24 -m conntrack --ctstate NEW -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">sudo iptables -A POSTROUTING -t nat -j MASQUERADE</span><br><span class="line"></span><br><span class="line">sudo vim /etc/network/interfaces</span><br><span class="line">编辑 Ubuntu 的网络配置文件 /etc/network/interfaces ，在文件末尾添加以下两行：</span><br><span class="line">pre-up iptables-restore &lt; /etc/iptables.rules #开机时启用 iptables 规则</span><br><span class="line">post-down iptables-save &gt; /etc/iptables.rules #关机前保存当前所有的 iptables 规则</span><br></pre></td></tr></table></figure></p><p>效果如下：<br><img src="/2018/06/06/Cuckoo-Sandbox学习-安装篇/ping.PNG" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Cuckoo Sandbox是一个开源的恶意文件自动化分析系统，通过Cuckoo Sandbox可以方便地帮助安全研究人员验证恶意程序的特征信息。&lt;/p&gt;
&lt;h2 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h2&gt;&lt;p&gt;本人在vmware中建立两个虚拟机，一个host，一个guest。&lt;br&gt;VMware 12 Pro&lt;br&gt;ubuntu-16.04.1-desktop-amd64&lt;br&gt;window7-64bit&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Cuckoo Sandbox" scheme="http://zeringzxh.github.io/categories/Cuckoo-Sandbox/"/>
    
    
      <category term="Cickoo Sandbox" scheme="http://zeringzxh.github.io/tags/Cickoo-Sandbox/"/>
    
      <category term="工具安装" scheme="http://zeringzxh.github.io/tags/%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向-smali语法</title>
    <link href="http://zeringzxh.github.io/2018/06/01/Android%E9%80%86%E5%90%91-smali%E8%AF%AD%E6%B3%95/"/>
    <id>http://zeringzxh.github.io/2018/06/01/Android逆向-smali语法/</id>
    <published>2018-06-01T02:56:06.000Z</published>
    <updated>2018-06-01T07:22:57.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h2><p>DVM运行Dalvik字节码，可执行文件格式dex(dalvik executable)，有点类似于机器码。DVM基于寄存器，JVM基于栈。</p><h2 id="smali语法"><a href="#smali语法" class="headerlink" title="smali语法"></a>smali语法</h2><a id="more"></a><h3 id="变量和参数寄存器命名方式"><a href="#变量和参数寄存器命名方式" class="headerlink" title="变量和参数寄存器命名方式"></a>变量和参数寄存器命名方式</h3><table><thead><tr><th style="text-align:center">v命名法</th><th style="text-align:center">p命名法</th><th style="text-align:center">寄存器含义</th></tr></thead><tbody><tr><td style="text-align:center">v0</td><td style="text-align:center">v0</td><td style="text-align:center">第一个局部变量寄存器</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">中间的局部变量寄存器</td></tr><tr><td style="text-align:center">vM-N</td><td style="text-align:center">p0</td><td style="text-align:center">第一个参数寄存器（通常为调用对象）</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">中间的参数寄存器</td></tr><tr><td style="text-align:center">vM-1</td><td style="text-align:center">pN-1</td><td style="text-align:center">第N个参数寄存器</td></tr></tbody></table><p>通常使用p命名法进行记录。</p><h3 id="类型描述符"><a href="#类型描述符" class="headerlink" title="类型描述符"></a>类型描述符</h3><table><thead><tr><th style="text-align:center">语法</th><th style="text-align:center">类型</th></tr></thead><tbody><tr><td style="text-align:center">—-</td><td style="text-align:center">——-</td></tr><tr><td style="text-align:center">V</td><td style="text-align:center">void</td></tr><tr><td style="text-align:center">Z</td><td style="text-align:center">boolean</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">byte</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">short</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">char</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">int</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">long</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">D</td><td style="text-align:center">double</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">java类</td></tr><tr><td style="text-align:center">[</td><td style="text-align:center">数组</td></tr></tbody></table><p><strong>注：</strong></p><ul><li>变量存放在寄存器中，寄存器为32位，支持任何类型，其中long，double是64位，使用两个相邻的寄存器。</li><li>[x表示一维数组，x代表基本类型，如[I代表int[],[[x代表二维数组。</li><li>Java语言存在大量对象，java.lang.String表示为<em>Ljava/lang/String;</em>；分号一定要加上。</li></ul><h3 id="方法和字段"><a href="#方法和字段" class="headerlink" title="方法和字段"></a>方法和字段</h3><h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#direct/virtual methods</span><br><span class="line">.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;</span><br><span class="line">    &lt;.registers&gt;</span><br><span class="line">    [.param]</span><br><span class="line">    [.prologue]</span><br><span class="line">    [.line]</span><br><span class="line">    &lt;.local&gt;</span><br><span class="line">    &lt;代码体&gt;</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><ul><li>#direct/virtual methods是注释，是baksmali添加的，访问权限和修饰关键字跟字段是一样的。</li><li>方法原型描述了方法的名称、参数与返回值。<ul><li>.registers 指令指定了方法中寄存器的总数,这个数量是参数和本地变量总和。</li><li>.param表明了方法的参数，每个.param指令表示一个参数，方法使用了几个参数就有几个.parameter指令。</li><li>.prologue指定了代码的开始处，混淆过的代码可能去掉了该指令。</li><li>.line指明了该处代码在源代码中的行号，同样，混淆后的代码可能去掉了行号。</li><li>.local 使用这个指定表明方法中非参寄存器</li></ul></li></ul><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用格式：Lpackage/name/ObjectName;-&gt;MethodName(III)Z<br>等价于bool package.name.ObjectName.MethodName（int,int,int）<br>例子：<br>method(I[[IILjava/lang/String;[Ljava/lang/Object;)Ljava/lang/Stirng<br>等价于<br>String method(int,int[][],int,String,Object[])</p><h4 id="字段调用"><a href="#字段调用" class="headerlink" title="字段调用"></a>字段调用</h4><p>格式：Lpackage/name/ObjectName;-&gt;FieldName:Ljava/lang/String;<br>等价于：package.name.ObjectName.FieldName</p><h3 id="头信息-类的主体信息"><a href="#头信息-类的主体信息" class="headerlink" title="头信息-类的主体信息"></a>头信息-类的主体信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//===================================================================</span><br><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;</span><br><span class="line">//=========smali文件头====================================================</span><br><span class="line">.class public Ltestdemo/hpp/cn/test/MainActivity;</span><br><span class="line">.super Landroid/support/v7/app/AppCompatActivity;</span><br><span class="line">.source &quot;MainActivity.java&quot;</span><br><span class="line">.implements Landroid/view/View$OnClickListener;</span><br><span class="line">//===================================================================</span><br></pre></td></tr></table></figure><p>.class &lt;访问权限&gt; [关键修饰字] &lt;类名&gt;;<br>.super &lt;父类名&gt;;<br>.source &lt;源文件名&gt;<br>.implements &lt;接口名&gt;</p><h3 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h3><p>共有12种判断语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if-eq vA, VB, cond_** 如果vA等于vB则跳转到cond_**。相当于if (vA==vB)</span><br><span class="line">if-ne vA, VB, cond_** 如果vA不等于vB则跳转到cond_**。相当于if (vA!=vB)</span><br><span class="line">if-lt vA, VB, cond_** 如果vA小于vB则跳转到cond_**。相当于if (vA&lt;vB)</span><br><span class="line">if-le vA, VB, cond_** 如果vA小于等于vB则跳转到cond_**。相当于if (vA&lt;=vB)</span><br><span class="line">if-gt vA, VB, cond_** 如果vA大于vB则跳转到cond_**。相当于if (vA&gt;vB)</span><br><span class="line">if-ge vA, VB, cond_** 如果vA大于等于vB则跳转到cond_**。相当于if (vA&gt;=vB)</span><br><span class="line"></span><br><span class="line">if-eqz vA, :cond_** 如果vA等于0则跳转到:cond_** 相当于if (VA==0)</span><br><span class="line">if-nez vA, :cond_** 如果vA不等于0则跳转到:cond_**相当于if (VA!=0)</span><br><span class="line">if-ltz vA, :cond_** 如果vA小于0则跳转到:cond_**相当于if (VA&lt;0)</span><br><span class="line">if-lez vA, :cond_** 如果vA小于等于0则跳转到:cond_**相当于if (VA&lt;=0)</span><br><span class="line">if-gtz vA, :cond_** 如果vA大于0则跳转到:cond_**相当于if (VA&gt;0)</span><br><span class="line">if-gez vA, :cond_** 如果vA大于等于0则跳转到:cond_**相当于if (VA&gt;=0)</span><br></pre></td></tr></table></figure></p><h3 id="其它基本指令"><a href="#其它基本指令" class="headerlink" title="其它基本指令"></a>其它基本指令</h3><p>smali字节码类似于汇编<br>.method　　方法<br>.end method　　函数结束<br>.parameter　　方法参数<br>.prologue　　方法开始<br>.line 12　　此方法位于第12行<br>.field private isFlag:z　　定义变量<br>move v0, v3 把v3寄存器的值移动到寄存器v0上<br>const-string v0, “MainActivity” 把字符串”MainActivity”赋值给v0寄存器<br>const/high16  v0, 0x7fo3　　把0x7fo3赋值给v0<br>invoke-super　　调用父函数<br>return-void　　函数返回void<br>new-instance　　创建实例<br>iput-object　　对象赋值<br>iget-object　　调用对象<br>invoke-static　　调用静态函数<br>invoke-direct　　调用函数</p><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//===================================================================</span><br><span class="line">@Override</span><br><span class="line">public void onClick(View view) &#123;</span><br><span class="line">    String str = &quot;Hello World!&quot;;</span><br><span class="line">    print(str);</span><br><span class="line">&#125;</span><br><span class="line">//===================================================================</span><br><span class="line"># virtual methods</span><br><span class="line"># 参数类型为Landroid/view/View，返回类型为V</span><br><span class="line">.method public onClick(Landroid/view/View;)V</span><br><span class="line">    # 表示有三个寄存器</span><br><span class="line">    .registers 3</span><br><span class="line">    # 参数View类型的view变量对应的是寄存器p1</span><br><span class="line">    .param p1, &quot;view&quot;    # Landroid/view/View;</span><br><span class="line"></span><br><span class="line">    .prologue</span><br><span class="line">    .line 24</span><br><span class="line">    #将&quot;Hello World!&quot;字符串放到寄存器v0中</span><br><span class="line">    const-string v0, &quot;Hello World!&quot;</span><br><span class="line"></span><br><span class="line">    .line 25</span><br><span class="line">    # 定义一个Ljava/lang/String类型的str变量对应本地寄存器v0</span><br><span class="line">    .local v0, &quot;str&quot;:Ljava/lang/String;</span><br><span class="line">    # 调用该类的print方法，该方法的参数类型为Ljava/lang/String，返回值为V</span><br><span class="line">    # 调用print方法传入的参数为&#123;p0, v0&#125;，及print(p0, v0)，p0为this，v0为&quot;Hello World!&quot;字符串</span><br><span class="line">    invoke-direct &#123;p0, v0&#125;, Ltestdemo/hpp/cn/annotationtest/MainActivity;-&gt;print(Ljava/lang/String;)V</span><br><span class="line"></span><br><span class="line">    .line 26</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br><span class="line">//===================================================================</span><br></pre></td></tr></table></figure></p><p>参考文章：<br><a href="https://blog.csdn.net/hp910315/article/details/51823236" target="_blank" rel="noopener">静态分析Android程序——smali文件解析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Dalvik&quot;&gt;&lt;a href=&quot;#Dalvik&quot; class=&quot;headerlink&quot; title=&quot;Dalvik&quot;&gt;&lt;/a&gt;Dalvik&lt;/h2&gt;&lt;p&gt;DVM运行Dalvik字节码，可执行文件格式dex(dalvik executable)，有点类似于机器码。DVM基于寄存器，JVM基于栈。&lt;/p&gt;
&lt;h2 id=&quot;smali语法&quot;&gt;&lt;a href=&quot;#smali语法&quot; class=&quot;headerlink&quot; title=&quot;smali语法&quot;&gt;&lt;/a&gt;smali语法&lt;/h2&gt;
    
    </summary>
    
      <category term="逆向" scheme="http://zeringzxh.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://zeringzxh.github.io/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="smali" scheme="http://zeringzxh.github.io/tags/smali/"/>
    
      <category term="android" scheme="http://zeringzxh.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>URL去重去似</title>
    <link href="http://zeringzxh.github.io/2018/05/24/url%E5%8E%BB%E9%87%8D%E5%8E%BB%E4%BC%BC/"/>
    <id>http://zeringzxh.github.io/2018/05/24/url去重去似/</id>
    <published>2018-05-24T01:48:54.000Z</published>
    <updated>2018-06-01T07:12:48.691Z</updated>
    
    <content type="html"><![CDATA[<h2 id="URL去重"><a href="#URL去重" class="headerlink" title="URL去重"></a>URL去重</h2><p>URL去重主要有两种方式：</p><ul><li>布隆过滤器去重</li><li><p>Hash表去重</p><a id="more"></a><h3 id="布隆过滤器去重"><a href="#布隆过滤器去重" class="headerlink" title="布隆过滤器去重"></a>布隆过滤器去重</h3><ol><li>需要一个数组和k个映射函数，初始将数组array所有位置都置0。</li><li>将元素集S={s1,s2……sn}中每个元素sj，通过k个映射函数{f1,f2……fk}映射为K个值{g1，g2……gk},将array中对应的array[g1],array[g2]……array[gk]置为1.</li><li>若元素item通过映射函数得到的k个值在array中对应的值全为1，则item在S中，否则不在。</li></ol><p>python有两个第三方插件实现了此功能：</p><ul><li>Python-bloomfilter<br>项目地址:<a href="https://github.com/jaybaird/Python-bloomfilter" target="_blank" rel="noopener">https://github.com/jaybaird/Python-bloomfilter</a></li><li>Pybloomfiltermmap<br>项目地址:<a href="https://github.com/axiak/Pybloomfiltermmap" target="_blank" rel="noopener">https://github.com/axiak/Pybloomfiltermmap</a><br>官方文档:<a href="https://axiak.github.io/pybloomfiltermmap/" target="_blank" rel="noopener">https://axiak.github.io/pybloomfiltermmap/</a></li></ul><p>Pybloomfiltermmap模块实现两类布隆过滤器：Bloomfilter和ScalableBloomfilter。<br>Bloomfilter是一个定容过滤器，error_rate指最大误报率；<br>ScalableBloomfilter是一个不定容过滤器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pybloomfilter <span class="keyword">import</span> BloomFilter</span><br><span class="line"><span class="comment"># 创建一个capacity等于100万，error rate等于0.001的bloomfilter对象</span></span><br><span class="line">bfilter = BloomFilter(<span class="number">1000000</span>,<span class="number">0.001</span>,<span class="string">'bf_test.bloom'</span>)</span><br></pre></td></tr></table></figure><p>方法add是添加元素，若元素已存在，则返回True，若不存在则返回False，并添加到过滤器中。</p><p>布隆过滤器存在一定的误判率。</p><h3 id="Hash表去重"><a href="#Hash表去重" class="headerlink" title="Hash表去重"></a>Hash表去重</h3><p>遍历URL列表，判断每个URL是否在去重后的列表里，如果不在，则加入列表。根据哈希表存放的位置，可以分为两种方式：一种是基于内存的Hash表去重；一种是基于硬盘的Hash表去重。</p><h4 id="方法一：利用内存Hash表去重"><a href="#方法一：利用内存Hash表去重" class="headerlink" title="方法一：利用内存Hash表去重"></a>方法一：利用内存Hash表去重</h4><p>使用如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> url_list:</span><br><span class="line">  <span class="keyword">if</span> url <span class="keyword">not</span> <span class="keyword">in</span> result:</span><br><span class="line">    result.append(url)</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>由于URL长度不固定，单个URL长度越长，使用URL存储内存和性能损耗过快，此时需对URL进行Hash运算压缩，如：16位md5运算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.x</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">print</span> hashlib.md5(<span class="string">"hello"</span>).hexdigest()[<span class="number">8</span>:<span class="number">-8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.x</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">print(hashlib.md5(<span class="string">"hello"</span>.encode(<span class="string">'utf-8'</span>)).hexdigest())[<span class="number">8</span>:<span class="number">-8</span>]</span><br></pre></td></tr></table></figure><h4 id="方法二：利用BerkeleyDB去重"><a href="#方法二：利用BerkeleyDB去重" class="headerlink" title="方法二：利用BerkeleyDB去重"></a>方法二：利用BerkeleyDB去重</h4><p>BerkeleyDB是一个key-value database，简单的说，就是一个在disk上的hash表。存储的是“key-value”键值对。<br>下载安装Berkeley DB安装。Python需要安装bsddb3模块来提供BerkeleyDB数据库的操作接口。<br>Berkeley DB次你在四种数据访问模式：</p><ul><li>btree：树结构，存储任意复杂key和value</li><li>hash：hash存储，访问量巨大时，效果好</li><li>queue：队列操作，只能存储定长数据，key必须是数字</li><li>recno：与queue相似，但支持边长value</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bsddb</span><br><span class="line">mydb = bsddb.db.DB()</span><br><span class="line">mydb.open(<span class="string">'mydb.db'</span>,dbtype = bsddb.db.DB_HASH, flags = bsddb.db.DB_CREATE)</span><br><span class="line">mydb.put(<span class="string">"key"</span>,<span class="string">"value"</span>)</span><br><span class="line">mydb.close()</span><br></pre></td></tr></table></figure><p>设置数据访问方法：<br>btree是 bsddb.db.DB_BTREE， hash是bsddb.db.DB_HASH<br>queu 是 bsddb.db.DB_QUEUE,  recno 是bsddb.db.DB_RECNO<br>设置flags参数为DB_CREATE表明如果数据文件不存在则新建一个空的数据文件。<br>使用DB的put方法存储一个Key/Value对</p></li></ul><h2 id="URL去似去含"><a href="#URL去似去含" class="headerlink" title="URL去似去含"></a>URL去似去含</h2><p>相似URL特征：</p><ul><li>协议相同（protocol）</li><li>主机名相同（host）</li><li>端口相同（port）</li><li>资源路劲相同（path）</li><li>参数名所组成列表相同或包含</li></ul><p>python2.x使用urlparse，python3.x使用urllib，以python2.x为例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urlparse</span><br><span class="line">url=<span class="string">'http://www.baidu.com:80/s?wd=python&amp;ie=utf-8#123'</span></span><br><span class="line">r=urlparse.urlparse(url)</span><br><span class="line"><span class="keyword">print</span> r</span><br><span class="line"><span class="keyword">print</span> r.netloc</span><br><span class="line"><span class="keyword">print</span> r.hostname</span><br><span class="line"><span class="keyword">print</span> r.port</span><br><span class="line"><span class="keyword">print</span> urlparse.parse_qs(r.query)</span><br><span class="line">res = urlparse.urlsplit(url)</span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ParseResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com:80'</span>, path=<span class="string">'/s'</span>, params=<span class="string">''</span>, query=<span class="string">'wd=python&amp;ie=utf-8'</span>, fragment=<span class="string">'123'</span>)</span><br><span class="line">www.baidu.com:80</span><br><span class="line">www.baidu.com</span><br><span class="line">80</span><br><span class="line">SplitResult(scheme=<span class="string">'http'</span>, netloc=<span class="string">'www.baidu.com:80'</span>, path=<span class="string">'/s'</span>, query=<span class="string">'wd=python&amp;ie=utf-8'</span>, fragment=<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure></p><p>r = urlparse.urlparse(url)返回一个6个元组，分别为scheme, netloc, path, params, query, fragment，ParseResult类还有几个常用方法：<br>res.username<br>res.password<br>res.hostname<br>res.port<br>res.geturl()<br>urlunparse与之相反,将6个元组组成一个string。<br>urlsplit将path与params合并为path，存在urlunsplit与之相反功能。<br>使用urlparse.parse_qs()函数获取r.query中的参数列表，输出为字典。<br><strong>注释：url必须以<em><a href="http://xxx" target="_blank" rel="noopener">http://xxx</a></em>开头,否则会出错。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;URL去重&quot;&gt;&lt;a href=&quot;#URL去重&quot; class=&quot;headerlink&quot; title=&quot;URL去重&quot;&gt;&lt;/a&gt;URL去重&lt;/h2&gt;&lt;p&gt;URL去重主要有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;布隆过滤器去重&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Hash表去重&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="爬虫" scheme="http://zeringzxh.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://zeringzxh.github.io/tags/python/"/>
    
      <category term="url" scheme="http://zeringzxh.github.io/tags/url/"/>
    
  </entry>
  
  <entry>
    <title>python学习-argparse模块</title>
    <link href="http://zeringzxh.github.io/2018/05/14/python%E5%AD%A6%E4%B9%A0-argparse%E6%A8%A1%E5%9D%97/"/>
    <id>http://zeringzxh.github.io/2018/05/14/python学习-argparse模块/</id>
    <published>2018-05-14T07:28:37.000Z</published>
    <updated>2018-05-24T01:53:09.326Z</updated>
    
    <content type="html"><![CDATA[<p>  argparse模块是python中用于解析命令行参数和选项的标准模块，方便用户在命令行中输入参数。</p><h2 id="argparse使用"><a href="#argparse使用" class="headerlink" title="argparse使用"></a>argparse使用</h2><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>先看一个简单的例子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.parse_args()</span><br></pre></td></tr></table></figure></p><ul><li>创建 ArgumentParser() 对象</li><li>使用 parse_args() 解析</li></ul><p>将上述代码保存并命名为test.py,运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: t.py [-h]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure></p><ul><li>不添加任何参数，无回显</li><li>添加-h参数，获取帮助，-h为默认预设参数</li></ul><h3 id="ArgumentParser函数解析"><a href="#ArgumentParser函数解析" class="headerlink" title="ArgumentParser函数解析"></a>ArgumentParser函数解析</h3><p>  使用help(argparse.ArgumentParser())查看函数帮助，如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class ArgumentParser(_AttributeHolder, _ActionsContainer)</span><br><span class="line"> |  Object <span class="keyword">for</span> parsing <span class="built_in">command</span> line strings into Python objects.</span><br><span class="line"> |</span><br><span class="line"> |  Keyword Arguments:</span><br><span class="line"> |      - prog -- The name of the program (default: sys.argv[0])</span><br><span class="line"> |      - usage -- A usage message (default: auto-generated from arguments)</span><br><span class="line"> |      - description -- A description of what the program does</span><br><span class="line"> |      - epilog -- Text following the argument descriptions</span><br><span class="line"> |      - parents -- Parsers whose arguments should be copied into this one</span><br><span class="line"> |      - formatter_class -- HelpFormatter class <span class="keyword">for</span> printing <span class="built_in">help</span> messages</span><br><span class="line"> |      - prefix_chars -- Characters that prefix optional arguments</span><br><span class="line"> |      - fromfile_prefix_chars -- Characters that prefix files containing</span><br><span class="line"> |          additional arguments</span><br><span class="line"> |      - argument_default -- The default value <span class="keyword">for</span> all arguments</span><br><span class="line"> |      - conflict_handler -- String indicating how to handle conflicts</span><br><span class="line"> |      - add_help -- Add a -h/-<span class="built_in">help</span> option</span><br><span class="line"> |</span><br><span class="line">......</span><br><span class="line"> |</span><br><span class="line"> |  Methods defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __init__(self, prog=None, usage=None, description=None, epilog=None, version=None, parents=[], formatter_class=&lt;class <span class="string">'argparse.HelpFormatter'</span>&gt;, prefix_chars=<span class="string">'-'</span>, fromfile_prefix_chars=None, argument_default=None, conflict_handler=<span class="string">'error'</span>, add_help=True)</span><br><span class="line"> ......</span><br></pre></td></tr></table></figure></p><p>常用参数解析：</p><ul><li>prog：程序名（默认为sys.argv[0]）</li><li>usage：程序的使用用例，默认情况下会自动生成</li><li>description：简短的描述这个程序的用途，help参数之前显示的信息。</li><li>parents：ArgumentParser对象组成列表，这些对象中的参数也要包含进来。</li><li>formatter_class：一个自定义帮助信息格式化输出的类。</li><li>prefix_chars：可选参数之前的前缀（默认为-)。</li><li>fromfile_prefix_chars：如果是从文件中读取参数，这个文件名参数的前缀（默认为None）。</li><li>conflict_handler：通常不需要，定义了处理冲突选项的策略。</li></ul><h3 id="add-argument-方法"><a href="#add-argument-方法" class="headerlink" title="add_argument() 方法"></a>add_argument() 方法</h3><p>使用add_argument()方法，用来定义程序可接受的命令行参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArgumentParser.add_argument(name or flags...[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest])</span><br></pre></td></tr></table></figure></p><ul><li>name or flags - 选项字符串的名字或者列表，例如 foo 或者 -f, –foo。</li><li>action - 命令行中该参数存在时的操作，默认值是 store<ul><li>store_ture，表示赋值为true；</li><li>append，将遇到的值存储成列表，也就是如果参数重复则会保存多个值;</li><li>append_const，将参数规范中定义的一个值保存到一个列表；</li><li>count，存储遇到的次数；</li></ul></li><li>default - 不指定参数时的默认值；</li><li>nargs - 应该读取的命令行参数个数，可以是具体的数字，或者是?号，当不指定值时对于 Positional argument 使用 default，对于 Optional argument 使用 const；或者是 * 号，表示 0 或多个参数；或者是 + 号表示 1 或多个参数。</li><li>required - 可选参数是否可以省略 (仅针对可选参数),默认为False；</li><li>const - action 和 nargs 所需要的常量值。</li><li>metavar - 对于必选参数默认就是参数名称，对于可选参数默认是必须存在参数后；</li><li>dest - 解析后的参数名称，默认情况下，对于可选参数选取最长的名称，中划线转换为下划线。</li></ul><h3 id="添加位置参数"><a href="#添加位置参数" class="headerlink" title="添加位置参数"></a>添加位置参数</h3><p>先看如下例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">"square"</span>, help=<span class="string">"display a square of a given number"</span>,</span><br><span class="line">                    type=int)</span><br><span class="line">args = parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> args</span><br><span class="line"><span class="keyword">print</span> args.square**<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line">t.py: error: too few arguments</span><br><span class="line"></span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  square      display a square of a given number</span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">$ python test.py 3</span><br><span class="line">Namespace(square=3)</span><br><span class="line">9</span><br><span class="line">$ python test.py three</span><br><span class="line">usage: test.py [-h] square</span><br><span class="line">t.py: error: argument square: invalid int value: <span class="string">'three'</span></span><br></pre></td></tr></table></figure></p><ul><li>运行程序，就必须设置一个参数。</li><li>parse_args()方法获取Namespace。</li></ul><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>通过两种方式指定</p><ol><li>通过<span style="background:#BDD3F7"> - </span>来指定短参数，如：<span style="background:#BDD3F7">-h</span></li><li>通过<span style="background:#BDD3F7"> – </span>来指定长参数，如：<span style="background:#BDD3F7">–help</span><br>修改test.py文件：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, prog=<span class="string">'python test.py &lt;OPTIONS&gt;'</span>,description=<span class="string">'test'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-a'</span>, <span class="string">'--all'</span>, help=<span class="string">"Perform all operations"</span>,metavar=<span class="string">'xx'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'-d'</span>, <span class="string">'--dns'</span>, help=<span class="string">"Perform"</span>,required=<span class="keyword">False</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">par=parser.parse_args()</span><br><span class="line"><span class="keyword">print</span> vars(par)</span><br><span class="line"><span class="keyword">print</span> vars(par)[<span class="string">'all'</span>]</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> vars(par):</span><br><span class="line">    <span class="keyword">print</span> v</span><br><span class="line">    <span class="keyword">print</span> vars(par)[v]</span><br></pre></td></tr></table></figure></li></ol><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py</span><br><span class="line">&#123;<span class="string">'all'</span>: None, <span class="string">'dns'</span>: False&#125;</span><br><span class="line">None</span><br><span class="line">all</span><br><span class="line">None</span><br><span class="line">dns</span><br><span class="line">False</span><br><span class="line">$ python test.py -h</span><br><span class="line">usage: python Stealth.py &lt;OPTIONS&gt; [-h] [-a xx] [-d]</span><br><span class="line"></span><br><span class="line">collect</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>       show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -a xx, --all xx  Perform all operations</span><br><span class="line">  -d, --dns        Perform</span><br><span class="line"></span><br><span class="line">$ python test.py -a</span><br><span class="line">usage: python Stealth.py &lt;OPTIONS&gt; [-h] [-a xx] [-d]</span><br><span class="line">python Stealth.py &lt;OPTIONS&gt;: error: argument -a/--all: expected one argument</span><br><span class="line">$ python test.py -a test1 -d</span><br><span class="line">&#123;<span class="string">'all'</span>: <span class="string">'test1'</span>, <span class="string">'dns'</span>: True&#125;</span><br><span class="line">test1</span><br><span class="line">all</span><br><span class="line">test1</span><br><span class="line">dns</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p><ul><li>存在metavar参数时，可选参数后必须接值</li><li>存在action=’store_true’，默认值为False</li><li>metavar和action=’store_true’不能共存</li></ul><h3 id="混合参数使用"><a href="#混合参数使用" class="headerlink" title="混合参数使用"></a>混合参数使用</h3><p>计算一个整数数列的最大值或求和：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.accumulate(args.integers))</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python test.py 1 2 3 4</span><br><span class="line">4</span><br><span class="line">$ python test.py 1 2 3 4 --sum</span><br><span class="line">10</span><br></pre></td></tr></table></figure></p><p>上述示例使用accumulate来重命名sum参数，与下面代码实现功能一样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Process some integers.'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'integers'</span>, metavar=<span class="string">'N'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                   help=<span class="string">'an integer for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                   const=sum, default=max,</span><br><span class="line">                   help=<span class="string">'sum the integers (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line">args = parser.parse_args()</span><br><span class="line">print(args.sum(args.integers))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  argparse模块是python中用于解析命令行参数和选项的标准模块，方便用户在命令行中输入参数。&lt;/p&gt;
&lt;h2 id=&quot;argparse使用&quot;&gt;&lt;a href=&quot;#argparse使用&quot; class=&quot;headerlink&quot; title=&quot;argparse使用&quot;&gt;&lt;/a&gt;argparse使用&lt;/h2&gt;
    
    </summary>
    
      <category term="python" scheme="http://zeringzxh.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://zeringzxh.github.io/tags/python/"/>
    
      <category term="argparse" scheme="http://zeringzxh.github.io/tags/argparse/"/>
    
  </entry>
  
</feed>
